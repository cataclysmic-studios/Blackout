-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local RunService = _services.RunService
local Metadata = TS.import(script, script.Parent, "metadata").Metadata
local Modding = TS.import(script, script.Parent, "modding").Modding
local Reflect = TS.import(script, script.Parent, "reflect").Reflect
local ArtificialDependency, Flamework
local Flamework = {}
do
	local _container = Flamework
	local flameworkConfig = {
		isDefault = true,
	}
	_container.flameworkConfig = flameworkConfig
	_container.isInitialized = false
	local isPreloading = false
	-- * @hidden
	local hasFlameworkIgnited
	local function resolveDependency(id)
		if isPreloading then
			local source, line = debug.info(2, "sl")
			warn("[Flamework] Attempting to load dependency '" .. (id .. "' during preloading."))
			warn("This is prone to race conditions and is not guaranteed to succeed.")
			warn("Script '" .. (source .. ("', Line " .. tostring(line))))
		elseif not hasFlameworkIgnited and Metadata.gameConfig.disableDependencyWarnings ~= true then
			local source, line = debug.info(2, "sl")
			warn("[Flamework] Dependency '" .. (id .. "' was loaded before ignition."))
			warn("This is considered bad practice and should be avoided.")
			warn("You can disable this warning in flamework.json")
			warn("Script '" .. (source .. ("', Line " .. tostring(line))))
		end
		return Modding.resolveDependency(ArtificialDependency, id, 0, {})
	end
	_container.resolveDependency = resolveDependency
	-- * @hidden
	local logIfVerbose
	local function _addPaths(...)
		local args = { ... }
		local preloadPaths = {}
		for _, arg in args do
			local service = table.remove(arg, 1)
			local currentPath = game:GetService(service)
			if service == "StarterPlayer" then
				if arg[1] ~= "StarterPlayerScripts" then
					error("StarterPlayer only supports StarterPlayerScripts")
				end
				if not RunService:IsClient() then
					error("The server cannot load StarterPlayer content")
				end
				currentPath = Players.LocalPlayer:WaitForChild("PlayerScripts")
				table.remove(arg, 1)
			end
			do
				local i = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < #arg) then
						break
					end
					currentPath = currentPath:WaitForChild(arg[i + 1])
				end
			end
			local _currentPath = currentPath
			table.insert(preloadPaths, _currentPath)
		end
		local preload = function(moduleScript)
			isPreloading = true
			local start = os.clock()
			local success, value = pcall(require, moduleScript)
			local endTime = math.floor((os.clock() - start) * 1000)
			isPreloading = false
			if not success then
				error(moduleScript:GetFullName() .. (" failed to preload (" .. (tostring(endTime) .. ("ms): " .. tostring(value)))))
			end
		end
		for _, path in preloadPaths do
			logIfVerbose("Preloading directory " .. path:GetFullName())
			if path:IsA("ModuleScript") then
				preload(path)
			end
			for _1, instance in path:GetDescendants() do
				if instance:IsA("ModuleScript") then
					preload(instance)
				end
			end
		end
	end
	_container._addPaths = _addPaths
	-- * @hidden
	local function _implements(object, id)
		local _exp = Reflect.getMetadatas(object, "flamework:implements")
		local _arg0 = function(impl)
			local _impl = impl
			local _id = id
			return table.find(_impl, _id) ~= nil
		end
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		for _k, _v in _exp do
			if _arg0(_v, _k - 1, _exp) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		return _result
	end
	_container._implements = _implements
	function logIfVerbose(...)
		local args = { ... }
		if Metadata.getLogLevel() == "verbose" then
			print("[Flamework (verbose)]", unpack(args))
		end
	end
	local function isConstructor(obj)
		return obj.new ~= nil and obj.constructor ~= nil
	end
	local function getIdentifier(obj, suffix)
		if suffix == nil then
			suffix = ""
		end
		local _condition = Reflect.getMetadata(obj, "identifier")
		if _condition == nil then
			_condition = "UnidentifiedFlameworkListener" .. suffix
		end
		return _condition
	end
	-- This returns a Map rather than an Array because table.sort is unstable and will not preserve element order.
	local function topologicalSort(objects)
		-- This implementation ignores circular dependency trees.
		local currentSize = 0
		local sorted = {}
		local visited = {}
		local visitor
		visitor = function(node)
			local _node = node
			if visited[_node] ~= nil then
				return nil
			end
			local _node_1 = node
			visited[_node_1] = true
			local _idToObj = Reflect.idToObj
			local _node_2 = node
			local object = _idToObj[_node_2]
			if not object then
				return nil
			end
			local dependencies = Reflect.getMetadata(object, "flamework:parameters")
			for _, dependency in dependencies or {} do
				visitor(dependency)
			end
			local _exp = node
			local _original = currentSize
			currentSize += 1
			sorted[_exp] = _original
		end
		for _, node in objects do
			visitor(node)
		end
		return sorted
	end
	local externalClasses = {}
	local isProfiling = Metadata.isProfiling()
	local function profilingThread(func, identifier)
		-- `profilebegin` will end when this thread dies.
		debug.profilebegin(identifier)
		debug.setmemorycategory(identifier)
		func()
	end
	local function profileYielding(func, identifier)
		if isProfiling then
			task.spawn(profilingThread, func, identifier)
		else
			task.spawn(func)
		end
	end
	--[[
		*
		* Allow an external module to be bootstrapped by Flamework.ignite()
	]]
	local function registerExternalClass(ctor)
		local _ctor = ctor
		externalClasses[_ctor] = true
	end
	_container.registerExternalClass = registerExternalClass
	hasFlameworkIgnited = false
	--[[
		*
		* Initialize Flamework.
		*
		* This will start up the lifecycle events on all currently registered
		* classes.
		*
		* You should preload all necessary directories before calling this
		* as newly registered classes will not run their lifecycle events.
		*
		* @returns All the dependencies that have been loaded.
	]]
	local function ignite(patchedConfig)
		if hasFlameworkIgnited then
			error("Flamework.ignite() should only be called once")
		end
		hasFlameworkIgnited = true
		if patchedConfig then
			for key, value in pairs(patchedConfig) do
				flameworkConfig[key] = value
			end
		end
		for ctor in Reflect.objToId do
			if not isConstructor(ctor) then
				continue
			end
			if not Reflect.getMetadata(ctor, "flamework:singleton") then
				continue
			end
			local isPatched = Reflect.getOwnMetadata(ctor, "flamework:isPatched")
			if flameworkConfig.loadOverride and (not (table.find(flameworkConfig.loadOverride, ctor) ~= nil) and not isPatched) then
				continue
			end
			local isExternal = Reflect.getOwnMetadata(ctor, "flamework:isExternal")
			if isExternal and not (externalClasses[ctor] ~= nil) then
				continue
			end
			Modding.resolveSingleton(ctor)
			logIfVerbose("Resolving singleton " .. tostring(ctor))
		end
		local dependencies = {}
		for ctor, dependency in Modding.getSingletons() do
			local _condition = Reflect.getMetadata(ctor, "flamework:loadOrder")
			if _condition == nil then
				_condition = 1
			end
			local loadOrder = _condition
			local _arg0 = { dependency, loadOrder }
			table.insert(dependencies, _arg0)
		end
		local _arg0 = function(_param)
			local obj = _param[1]
			return getIdentifier(obj)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#dependencies)
		for _k, _v in dependencies do
			_newValue[_k] = _arg0(_v, _k - 1, dependencies)
		end
		-- ▲ ReadonlyArray.map ▲
		local sortedDependencies = topologicalSort(_newValue)
		local start = {}
		local init = {}
		local tick = {}
		local render = {}
		local physics = {}
		local _arg0_1 = function(_param, _param_1)
			local depA = _param[1]
			local aOrder = _param[2]
			local depB = _param_1[1]
			local bOrder = _param_1[2]
			if aOrder ~= bOrder then
				return aOrder < bOrder
			end
			local _arg0_2 = getIdentifier(depA)
			local aIndex = sortedDependencies[_arg0_2]
			local _arg0_3 = getIdentifier(depB)
			local bIndex = sortedDependencies[_arg0_3]
			return aIndex < bIndex
		end
		table.sort(dependencies, _arg0_1)
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnTick")
			tick[_object] = _arg1
			return tick
		end, "$:flamework@OnTick")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnPhysics")
			physics[_object] = _arg1
			return physics
		end, "$:flamework@OnPhysics")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnRender")
			render[_object] = _arg1
			return render
		end, "$:flamework@OnRender")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = tick[_object] ~= nil
			tick[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnTick")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = physics[_object] ~= nil
			physics[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnPhysics")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = render[_object] ~= nil
			render[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnRender")
		for _, _binding in dependencies do
			local dependency = _binding[1]
			if Flamework._implements(dependency, "$:flamework@OnInit") then
				local _arg0_2 = { dependency, getIdentifier(dependency) }
				table.insert(init, _arg0_2)
			end
			if Flamework._implements(dependency, "$:flamework@OnStart") then
				local _arg0_2 = { dependency, getIdentifier(dependency) }
				table.insert(start, _arg0_2)
			end
		end
		for _, _binding in init do
			local dependency = _binding[1]
			local identifier = _binding[2]
			if isProfiling then
				debug.setmemorycategory(identifier)
			end
			logIfVerbose("OnInit " .. identifier)
			local initResult = dependency:onInit()
			if TS.Promise.is(initResult) then
				local status, value = initResult:awaitStatus()
				if status == TS.Promise.Status.Rejected then
					error("OnInit failed for dependency '" .. (identifier .. ("'. " .. tostring(value))))
				end
			end
		end
		debug.resetmemorycategory()
		_container.isInitialized = true
		RunService.Heartbeat:Connect(function(dt)
			for dependency, identifier in tick do
				profileYielding(function()
					return dependency:onTick(dt)
				end, identifier)
			end
		end)
		RunService.Stepped:Connect(function(time, dt)
			for dependency, identifier in physics do
				profileYielding(function()
					return dependency:onPhysics(dt, time)
				end, identifier)
			end
		end)
		if RunService:IsClient() then
			RunService.RenderStepped:Connect(function(dt)
				for dependency, identifier in render do
					profileYielding(function()
						return dependency:onRender(dt)
					end, identifier)
				end
			end)
		end
		for _, _binding in start do
			local dependency = _binding[1]
			local identifier = _binding[2]
			logIfVerbose("OnStart " .. identifier)
			profileYielding(function()
				return dependency:onStart()
			end, identifier)
		end
	end
	_container.ignite = ignite
	--[[
		*
		* Preload the specified paths by requiring all ModuleScript descendants.
	]]
	--[[
		*
		* Preload the specified paths by requiring all ModuleScript descendants.
	]]
	--[[
		*
		* Retrieve the identifier for the specified type.
	]]
	--[[
		*
		* Check if the constructor implements the specified interface.
	]]
	--[[
		*
		* Check if object implements the specified interface.
	]]
	--[[
		*
		* Creates a type guard from any arbitrary type.
	]]
	--[[
		*
		* Hash a function using the method used internally by Flamework.
		* If a context is provided, then Flamework will create a new hash
		* if the specified string does not have one in that context.
		* @param str The string to hash
		* @param context A scope for the hash
	]]
	--[[
		*
		* Utility for use in test suites, not recommended for anything else.
	]]
	local Testing = {}
	do
		local _container_1 = Testing
		local function patchDependency(patchedClass, id)
			if id == nil then
				error("Patching failed, no ID")
			end
			local _idToObj = Reflect.idToObj
			local _id = id
			local idCtor = _idToObj[_id]
			if idCtor == nil then
				error("Dependency " .. (id .. " was not found and cannot be patched."))
			end
			if Modding.getSingletons()[idCtor] ~= nil then
				error(id .. " has already been resolved, continuing is unsafe")
			end
			local objMetadata = Reflect.metadata[idCtor]
			if not objMetadata then
				error("Dependency " .. (id .. " has no existing metadata."))
			end
			Reflect.defineMetadata(idCtor, "flamework:isPatched", true)
			Reflect.metadata[idCtor] = nil
			local _metadata = Reflect.metadata
			local _patchedClass = patchedClass
			_metadata[_patchedClass] = objMetadata
			local _objToId = Reflect.objToId
			local _patchedClass_1 = patchedClass
			local _id_1 = id
			_objToId[_patchedClass_1] = _id_1
			local _idToObj_1 = Reflect.idToObj
			local _id_2 = id
			local _patchedClass_2 = patchedClass
			_idToObj_1[_id_2] = _patchedClass_2
		end
		_container_1.patchDependency = patchDependency
	end
	_container.Testing = Testing
end
--[[
	*
	* An internal class used for resolving the Dependency<T> macro.
]]
do
	ArtificialDependency = setmetatable({}, {
		__tostring = function()
			return "ArtificialDependency"
		end,
	})
	ArtificialDependency.__index = ArtificialDependency
	function ArtificialDependency.new(...)
		local self = setmetatable({}, ArtificialDependency)
		return self:constructor(...) or self
	end
	function ArtificialDependency:constructor()
	end
end
Reflect.defineMetadata(ArtificialDependency, "identifier", "$:flamework@ArtificialDependency")
Reflect.defineMetadata(ArtificialDependency, "flamework:isArtificial", true)
--[[
	*
	* Register a class as a Service.
	*
	* @server
	* @metadata flamework:implements flamework:parameters injectable
]]
local Service = Modding.createDecorator("Class", function(descriptor, _param)
	local cfg = _param[1]
	if RunService:IsServer() then
		Reflect.defineMetadata(descriptor.object, "flamework:singleton", true)
		local _fn = Reflect
		local _exp = descriptor.object
		local _result = cfg
		if _result ~= nil then
			_result = _result.loadOrder
		end
		_fn.defineMetadata(_exp, "flamework:loadOrder", _result)
	end
end)
--[[
	*
	* Register a class as a Controller.
	*
	* @client
	* @metadata flamework:implements flamework:parameters injectable
]]
local Controller = Modding.createDecorator("Class", function(descriptor, _param)
	local cfg = _param[1]
	if RunService:IsClient() then
		Reflect.defineMetadata(descriptor.object, "flamework:singleton", true)
		local _fn = Reflect
		local _exp = descriptor.object
		local _result = cfg
		if _result ~= nil then
			_result = _result.loadOrder
		end
		_fn.defineMetadata(_exp, "flamework:loadOrder", _result)
	end
end)
--[[
	*
	* Marks this class as an external class.
	*
	* External classes are designed for packages and won't be
	* bootstrapped unless explicitly specified. Excluding this
	* inside of a package will make the class load as long as
	* it has been loaded.
]]
local External = Modding.createDecorator("Class", function(descriptor)
	Reflect.defineMetadata(descriptor.object, "flamework:isExternal", true)
end)
--[[
	*
	* Hook into the OnInit lifecycle event.
]]
--[[
	*
	* Hook into the OnStart lifecycle event.
]]
--[[
	*
	* Hook into the OnTick lifecycle event.
	* Equivalent to: RunService.Heartbeat
]]
--[[
	*
	* Hook into the OnPhysics lifecycle event.
	* Equivalent to: RunService.Stepped
]]
--[[
	*
	* Hook into the OnRender lifecycle event.
	* Equivalent to: RunService.RenderStepped
	*
	* @client
]]
return {
	Flamework = Flamework,
	Service = Service,
	Controller = Controller,
	External = External,
}
