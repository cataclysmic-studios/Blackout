-- Compiled with roblox-ts v2.0.2
local TS = _G[script]
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local _errors = TS.import(script, script.Parent, "errors")
local getFunctionError = _errors.getFunctionError
local NetworkingFunctionError = _errors.NetworkingFunctionError
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local Skip = TS.import(script, script.Parent.Parent, "middleware", "skip").Skip
local fireNetworkHandler = TS.import(script, script.Parent.Parent, "handlers").fireNetworkHandler
local createServerMethod, getRequestInfo, getProcessResult
local function createServerHandler(serverRemotes, clientRemotes, networkInfos, serverEvents, clientEvents, middlewareFactoryList)
	local handler = {}
	local processors = {}
	local players = {}
	local function createMethod(name, networkInfo, remote)
		if handler[name] ~= nil then
			return nil
		end
		local _exp = (serverEvents[name] or clientEvents[name])[2]
		local _result = middlewareFactoryList
		if _result ~= nil then
			_result = _result[name]
		end
		local _condition = _result
		if _condition == nil then
			_condition = {}
		end
		handler[name] = createServerMethod(_exp, _condition, processors, networkInfo, players, name, remote)
	end
	for alias, remote in clientRemotes do
		-- create server method
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnServerEvent:Connect(function(player, id, processResult, result)
			local _id = id
			if not (type(_id) == "number") then
				return nil
			end
			local requestInfo = getRequestInfo(player, players)
			local _requests = requestInfo.requests
			local _id_1 = id
			local request = _requests[_id_1]
			local _requests_1 = requestInfo.requests
			local _id_2 = id
			_requests_1[_id_2] = nil
			if request then
				request(result, getFunctionError(processResult))
			end
		end)
	end
	for alias, remote in serverRemotes do
		-- invoke callback
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnServerEvent:Connect(function(player, id, ...)
			local args = { ... }
			local guards = serverEvents[name]
			if not guards then
				return nil
			end
			do
				local i = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < #guards[1]) then
						break
					end
					local guard = guards[1][i + 1]
					if not guard(args[i + 1]) then
						fireNetworkHandler("onBadRequest", player, networkInfo, i)
						return remote:FireClient(player, id, NetworkingFunctionError.BadRequest)
					end
				end
			end
			local processor = processors[name]
			if processor then
				local result = processor(player, unpack(args))
				local _arg0 = function(value)
					return remote:FireClient(player, id, getProcessResult(value), value)
				end
				result:andThen(_arg0):catch(function(reason)
					warn("Failed to process request to " .. name)
					warn(reason)
					remote:FireClient(player, id, false)
				end)
			else
				remote:FireClient(player, id, false)
			end
		end)
	end
	Players.PlayerRemoving:Connect(function(player)
		local _player = player
		players[_player] = nil
	end)
	return handler
end
local timeout
function createServerMethod(guard, middleware, processors, networkInfo, players, name, remote)
	local method = {
		invoke = function(self, player, ...)
			local args = { ... }
			return TS.Promise.race({ timeout(10, NetworkingFunctionError.Timeout), TS.Promise.new(function(resolve, reject, onCancel)
				local requestInfo = getRequestInfo(player, players)
				local _original = requestInfo.nextId
				requestInfo.nextId += 1
				local id = _original
				local _requests = requestInfo.requests
				local _arg1 = function(value, rejection)
					if rejection then
						return reject(rejection)
					end
					if not guard(value) then
						fireNetworkHandler("onBadResponse", player, networkInfo)
						return reject(NetworkingFunctionError.InvalidResult)
					end
					resolve(value)
				end
				_requests[id] = _arg1
				onCancel(function()
					requestInfo.requests[id] = nil
				end)
				remote:FireClient(player, id, unpack(args))
			end) })
		end,
		setCallback = function(self, callback)
			local _processors = processors
			local _name = name
			if _processors[_name] ~= nil then
				warn("Function.setCallback was called multiple times for " .. name)
			end
			local processor = createMiddlewareProcessor(middleware, networkInfo, callback)
			local _processors_1 = processors
			local _name_1 = name
			_processors_1[_name_1] = processor
		end,
		predict = function(self, player, ...)
			local args = { ... }
			return TS.Promise.new(function(resolve, reject)
				local _processors = processors
				local _name = name
				local processor = _processors[_name]
				if not processor then
					return reject(NetworkingFunctionError.Unprocessed)
				end
				resolve(processor(player, unpack(args)))
			end)
		end,
	}
	setmetatable(method, {
		__call = function(method, player, ...)
			local args = { ... }
			return method:invoke(player, unpack(args))
		end,
	})
	return method
end
function getRequestInfo(player, map)
	local _map = map
	local _player = player
	local requestInfo = _map[_player]
	if requestInfo then
		return requestInfo
	end
	requestInfo = {
		nextId = 0,
		requests = {},
	}
	local _map_1 = map
	local _player_1 = player
	local _requestInfo = requestInfo
	_map_1[_player_1] = _requestInfo
	return requestInfo
end
function timeout(timeout, rejectValue)
	local _exp = TS.Promise.delay(timeout)
	local _arg0 = function()
		return TS.Promise.reject(rejectValue)
	end
	return _exp:andThen(_arg0)
end
function getProcessResult(value)
	return if value == Skip then NetworkingFunctionError.Cancelled else true
end
return {
	createServerHandler = createServerHandler,
}
