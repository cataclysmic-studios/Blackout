"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const child_process_1 = require("child_process");
const build_1 = __importDefault(require("./build"));
const CLIError_1 = require("../errors/CLIError");
const fs_extra_1 = __importDefault(require("fs-extra"));
const kleur_1 = __importDefault(require("kleur"));
const lookpath_1 = require("lookpath");
const path_1 = __importDefault(require("path"));
const prompts_1 = __importDefault(require("prompts"));
const constants_1 = require("../../Shared/constants");
const benchmark_1 = require("../../Shared/util/benchmark");
const typescript_1 = __importDefault(require("typescript"));
const yargs_1 = __importDefault(require("yargs"));
var InitMode;
(function (InitMode) {
    InitMode["None"] = "none";
    InitMode["Game"] = "game";
    InitMode["Place"] = "place";
    InitMode["Model"] = "model";
    InitMode["Plugin"] = "plugin";
    InitMode["Package"] = "package";
})(InitMode || (InitMode = {}));
var PackageManager;
(function (PackageManager) {
    PackageManager["NPM"] = "npm";
    PackageManager["Yarn"] = "yarn";
    PackageManager["PNPM"] = "pnpm";
})(PackageManager || (PackageManager = {}));
const packageManagerCommands = {
    [PackageManager.NPM]: {
        init: "npm init -y",
        devInstall: "npm install --silent -D",
        build: "npm run build",
    },
    [PackageManager.Yarn]: {
        init: "yarn init -y",
        devInstall: "yarn add --silent -D",
        build: "yarn run build",
    },
    [PackageManager.PNPM]: {
        init: "pnpm init",
        devInstall: "pnpm install --silent -D",
        build: "pnpm run build",
    },
};
function cmd(cmdStr) {
    return new Promise((resolve, reject) => {
        (0, child_process_1.exec)(cmdStr, (error, stdout) => {
            if (error) {
                reject(error);
            }
            resolve(stdout);
        });
    }).catch((error) => {
        throw new CLIError_1.CLIError(`Command "${error.cmd}" exited with code ${error.code}\n\n${error.message}`);
    });
}
function getNonDevCompilerVersion() {
    var _a, _b;
    return (_b = (_a = constants_1.COMPILER_VERSION.match(/^(.+)-dev.+$/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : constants_1.COMPILER_VERSION;
}
const TEMPLATES_DIR = path_1.default.join(constants_1.PACKAGE_ROOT, "templates");
const GIT_IGNORE = ["/node_modules", "/out", "/include", "*.tsbuildinfo"];
async function init(argv, initMode) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const [npmAvailable, pnpmAvailable, yarnAvailable, gitAvailable] = (await Promise.allSettled(["npm", "pnpm", "yarn", "git"].map(v => (0, lookpath_1.lookpath)(v)))).map(v => (v.status === "fulfilled" ? v.value !== undefined : true));
    const packageManagerExistance = {
        [PackageManager.NPM]: npmAvailable,
        [PackageManager.PNPM]: pnpmAvailable,
        [PackageManager.Yarn]: yarnAvailable,
    };
    const packageManagerCount = Object.values(packageManagerExistance).filter(exists => exists).length;
    const { template = initMode, git = (_b = (_a = argv.git) !== null && _a !== void 0 ? _a : (argv.yes && gitAvailable)) !== null && _b !== void 0 ? _b : false, eslint = (_d = (_c = argv.eslint) !== null && _c !== void 0 ? _c : argv.yes) !== null && _d !== void 0 ? _d : false, prettier = (_f = (_e = argv.prettier) !== null && _e !== void 0 ? _e : argv.yes) !== null && _f !== void 0 ? _f : false, vscode = (_h = (_g = argv.vscode) !== null && _g !== void 0 ? _g : argv.yes) !== null && _h !== void 0 ? _h : false, packageManager = (_j = argv.packageManager) !== null && _j !== void 0 ? _j : PackageManager.NPM, } = await (0, prompts_1.default)([
        {
            type: () => initMode === InitMode.None && "select",
            name: "template",
            message: "Select template",
            choices: [InitMode.Game, InitMode.Model, InitMode.Plugin, InitMode.Package].map(value => ({
                title: value,
                value,
            })),
            initial: 0,
        },
        {
            type: () => argv.git === undefined && argv.yes === undefined && gitAvailable && "confirm",
            name: "git",
            message: "Configure Git",
            initial: true,
        },
        {
            type: () => argv.eslint === undefined && argv.yes === undefined && "confirm",
            name: "eslint",
            message: "Configure ESLint",
            initial: true,
        },
        {
            type: () => argv.prettier === undefined && argv.yes === undefined && "confirm",
            name: "prettier",
            message: "Configure Prettier",
            initial: true,
        },
        {
            type: () => argv.vscode === undefined && argv.yes === undefined && "confirm",
            name: "vscode",
            message: "Configure VSCode Project Settings",
            initial: true,
        },
        {
            type: () => argv.packageManager === undefined && packageManagerCount > 1 && argv.yes === undefined && "select",
            name: "packageManager",
            message: "Multiple package managers detected. Select package manager:",
            choices: Object.entries(PackageManager)
                .filter(([, packageManager]) => packageManagerExistance[packageManager])
                .map(([managerDisplayName, managerEnum]) => ({
                title: managerDisplayName,
                value: managerEnum,
            })),
        },
    ], { onCancel: () => process.exit(1) });
    const cwd = process.cwd();
    const paths = {
        packageJson: path_1.default.join(cwd, "package.json"),
        packageLockJson: path_1.default.join(cwd, "package-lock.json"),
        tsconfig: path_1.default.join(cwd, "tsconfig.json"),
        gitignore: path_1.default.join(cwd, ".gitignore"),
        eslintrc: path_1.default.join(cwd, ".eslintrc"),
        prettierrc: path_1.default.join(cwd, ".prettierrc"),
        settings: path_1.default.join(cwd, ".vscode", "settings.json"),
        extensions: path_1.default.join(cwd, ".vscode", "extensions.json"),
    };
    const templateDir = path_1.default.join(TEMPLATES_DIR, template);
    const pathValues = Object.values(paths);
    for (const fileName of await fs_extra_1.default.readdir(templateDir)) {
        pathValues.push(fileName);
    }
    const existingPaths = new Array();
    for (const filePath of pathValues) {
        if (filePath && (await fs_extra_1.default.pathExists(filePath))) {
            const stat = await fs_extra_1.default.stat(filePath);
            if (stat.isFile() || stat.isSymbolicLink() || (await fs_extra_1.default.readdir(filePath)).length > 0) {
                existingPaths.push(path_1.default.relative(cwd, filePath));
            }
        }
    }
    if (existingPaths.length > 0) {
        const pathInfo = existingPaths.map(v => `  - ${kleur_1.default.yellow(v)}\n`).join("");
        throw new CLIError_1.CLIError(`Cannot initialize project, process could overwrite:\n${pathInfo}`);
    }
    const selectedPackageManager = packageManagerCommands[packageManager];
    await (0, benchmark_1.benchmark)("Initializing package.json..", async () => {
        await cmd(selectedPackageManager.init);
        const pkgJson = await fs_extra_1.default.readJson(paths.packageJson);
        pkgJson.scripts = {
            build: "rbxtsc",
            watch: "rbxtsc -w",
        };
        if (template === InitMode.Package) {
            pkgJson.name = constants_1.RBXTS_SCOPE + "/" + pkgJson.name;
            pkgJson.main = "out/init.lua";
            pkgJson.types = "out/index.d.ts";
            pkgJson.files = ["out", "!**/*.tsbuildinfo"];
            pkgJson.publishConfig = { access: "public" };
            pkgJson.scripts.prepublishOnly = selectedPackageManager.build;
        }
        await fs_extra_1.default.outputFile(paths.packageJson, JSON.stringify(pkgJson, null, 2));
    });
    if (git) {
        await (0, benchmark_1.benchmark)("Initializing Git..", async () => {
            try {
                await cmd("git init");
            }
            catch (error) {
                if (!(error instanceof CLIError_1.CLIError))
                    throw error;
                throw new CLIError_1.CLIError(`${error.diagnostics[0].messageText}\nDo you not have Git installed? Git CLI is required to use Git functionality. If you do not wish to use Git, answer no to "Configure Git".`);
            }
            await fs_extra_1.default.outputFile(paths.gitignore, GIT_IGNORE.join("\n") + "\n");
        });
    }
    await (0, benchmark_1.benchmark)("Installing dependencies..", async () => {
        const devDependencies = [
            "@rbxts/types",
            `@rbxts/compiler-types@compiler-${getNonDevCompilerVersion()}`,
            "typescript",
        ];
        if (prettier) {
            devDependencies.push("prettier");
        }
        if (eslint) {
            devDependencies.push("eslint", "@typescript-eslint/eslint-plugin", "@typescript-eslint/parser", "eslint-plugin-roblox-ts");
            if (prettier) {
                devDependencies.push("eslint-config-prettier", "eslint-plugin-prettier");
            }
        }
        await cmd(`${selectedPackageManager.devInstall} ${devDependencies.join(" ")}`);
    });
    if (eslint) {
        await (0, benchmark_1.benchmark)("Configuring ESLint..", async () => {
            const eslintConfig = {
                parser: "@typescript-eslint/parser",
                parserOptions: {
                    jsx: true,
                    useJSXTextNode: true,
                    ecmaVersion: 2018,
                    sourceType: "module",
                    project: "./tsconfig.json",
                },
                ignorePatterns: ["/out"],
                plugins: ["@typescript-eslint", "roblox-ts"],
                extends: [
                    "eslint:recommended",
                    "plugin:@typescript-eslint/recommended",
                    "plugin:roblox-ts/recommended",
                ],
                rules: typescript_1.default.identity({}),
            };
            if (prettier) {
                eslintConfig.plugins.push("prettier");
                eslintConfig.extends.push("plugin:prettier/recommended");
                eslintConfig.rules["prettier/prettier"] = "warn";
            }
            await fs_extra_1.default.outputFile(paths.eslintrc, JSON.stringify(eslintConfig, undefined, "\t"));
        });
    }
    if (prettier) {
        await (0, benchmark_1.benchmark)("Configuring prettier..", async () => {
            const prettierConfig = {
                printWidth: 120,
                tabWidth: 4,
                trailingComma: "all",
                useTabs: true,
            };
            await fs_extra_1.default.outputFile(paths.prettierrc, JSON.stringify(prettierConfig, undefined, "\t"));
        });
    }
    if (vscode) {
        await (0, benchmark_1.benchmark)("Configuring vscode..", async () => {
            const extensions = {
                recommendations: ["roblox-ts.vscode-roblox-ts"],
            };
            const settings = {
                "typescript.tsdk": "node_modules/typescript/lib",
                "files.eol": "\n",
            };
            if (eslint) {
                extensions.recommendations.push("dbaeumer.vscode-eslint");
                Object.assign(settings, {
                    "[typescript]": {
                        "editor.defaultFormatter": "dbaeumer.vscode-eslint",
                        "editor.formatOnSave": true,
                    },
                    "[typescriptreact]": {
                        "editor.defaultFormatter": "dbaeumer.vscode-eslint",
                        "editor.formatOnSave": true,
                    },
                    "eslint.run": "onType",
                    "eslint.format.enable": true,
                });
            }
            else if (prettier) {
                extensions.recommendations.push("esbenp.prettier-vscode");
                Object.assign(settings, {
                    "[typescript]": {
                        "editor.defaultFormatter": "esbenp.prettier-vscode",
                        "editor.formatOnSave": true,
                    },
                    "[typescriptreact]": {
                        "editor.defaultFormatter": "esbenp.prettier-vscode",
                        "editor.formatOnSave": true,
                    },
                });
            }
            await fs_extra_1.default.outputFile(paths.extensions, JSON.stringify(extensions, undefined, "\t"));
            await fs_extra_1.default.outputFile(paths.settings, JSON.stringify(settings, undefined, "\t"));
        });
    }
    await (0, benchmark_1.benchmark)("Copying template files..", async () => {
        await fs_extra_1.default.copy(templateDir, cwd);
    });
    await (0, benchmark_1.benchmark)("Compiling..", () => build_1.default.handler({
        logTruthyChanges: false,
        noInclude: false,
        project: ".",
        usePolling: false,
        verbose: false,
        watch: false,
        writeOnlyChanged: false,
        optimizedLoops: false,
        $0: argv.$0,
        _: argv._,
    }));
}
const GAME_DESCRIPTION = "Generate a Roblox place";
const MODEL_DESCRIPTION = "Generate a Roblox model";
const PLUGIN_DESCRIPTION = "Generate a Roblox Studio plugin";
const PACKAGE_DESCRIPTION = "Generate a roblox-ts npm package";
module.exports = typescript_1.default.identity({
    command: "init",
    describe: "Create a project from a template",
    builder: () => yargs_1.default
        .option("yes", {
        alias: "y",
        boolean: true,
        describe: "recommended options",
    })
        .option("git", {
        boolean: true,
        describe: "Configure Git",
    })
        .option("eslint", {
        boolean: true,
        describe: "Configure ESLint",
    })
        .option("prettier", {
        boolean: true,
        describe: "Configure Prettier",
    })
        .option("vscode", {
        boolean: true,
        describe: "Configure VSCode Project Settings",
    })
        .option("packageManager", {
        choices: Object.values(PackageManager),
        describe: "Choose an alternative package manager",
    })
        .command([InitMode.Game, InitMode.Place], GAME_DESCRIPTION, {}, argv => init(argv, InitMode.Game))
        .command(InitMode.Model, MODEL_DESCRIPTION, {}, argv => init(argv, InitMode.Model))
        .command(InitMode.Plugin, PLUGIN_DESCRIPTION, {}, argv => init(argv, InitMode.Plugin))
        .command(InitMode.Package, PACKAGE_DESCRIPTION, {}, argv => init(argv, InitMode.Package)),
    handler: argv => init(argv, InitMode.None),
});
//# sourceMappingURL=init.js.map