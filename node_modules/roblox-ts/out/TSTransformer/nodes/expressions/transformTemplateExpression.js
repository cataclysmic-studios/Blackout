"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTemplateExpression = void 0;
const luau_ast_1 = __importDefault(require("@roblox-ts/luau-ast"));
const diagnostics_1 = require("../../../Shared/diagnostics");
const assert_1 = require("../../../Shared/util/assert");
const DiagnosticService_1 = require("../../classes/DiagnosticService");
const createStringFromLiteral_1 = require("../../util/createStringFromLiteral");
const ensureTransformOrder_1 = require("../../util/ensureTransformOrder");
const expressionChain_1 = require("../../util/expressionChain");
const types_1 = require("../../util/types");
const typescript_1 = __importDefault(require("typescript"));
function transformTemplateExpression(state, node) {
    (0, assert_1.assert)(node.templateSpans.length > 0);
    const expressions = new Array();
    if (node.head.text.length > 0) {
        expressions.push((0, createStringFromLiteral_1.createStringFromLiteral)(node.head));
    }
    const orderedExpressions = (0, ensureTransformOrder_1.ensureTransformOrder)(state, node.templateSpans.map(templateSpan => templateSpan.expression));
    for (let i = 0; i < node.templateSpans.length; i++) {
        const templateSpan = node.templateSpans[i];
        let expression = orderedExpressions[i];
        const type = state.getType(templateSpan.expression);
        if (!(0, types_1.isDefinitelyType)(type, types_1.isStringType)) {
            if ((0, types_1.isDefinitelyType)(type, (0, types_1.isLuaTupleType)(state))) {
                DiagnosticService_1.DiagnosticService.addDiagnostic(diagnostics_1.errors.noLuaTupleInTemplateExpression(templateSpan.expression));
            }
            if (typescript_1.default.isCallExpression(templateSpan.expression) && (0, types_1.isPossiblyType)(type, types_1.isUndefinedType)) {
                expression = luau_ast_1.default.create(luau_ast_1.default.SyntaxKind.ParenthesizedExpression, { expression });
            }
            expression = luau_ast_1.default.call(luau_ast_1.default.globals.tostring, [expression]);
        }
        expressions.push(expression);
        if (templateSpan.literal.text.length > 0) {
            expressions.push((0, createStringFromLiteral_1.createStringFromLiteral)(templateSpan.literal));
        }
    }
    return (0, expressionChain_1.binaryExpressionChain)(expressions, "..");
}
exports.transformTemplateExpression = transformTemplateExpression;
//# sourceMappingURL=transformTemplateExpression.js.map